name: Pull Request Workflow

on:
  pull_request:
    branches: [ main ]

jobs:
  test-and-report:
    name: Test and Report
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.10']

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Needed for PR comments and diff analysis

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}

    - name: Install Poetry
      run: |
        curl -sSL https://install.python-poetry.org | python3 -

    - name: Install dependencies
      run: |
        poetry config virtualenvs.create false
        poetry install --no-interaction
        python -m pip install --upgrade pip pytest pytest-cov

    - name: Discover Python packages
      id: discover_packages
      run: |
        # Find all top-level Python packages in project root
        PACKAGES=$(find . -maxdepth 1 -type d -not -path "*/\.*" -not -path "./tests" -not -path "./scripts" -not -path "./venv" -not -path "./.venv" -name "*" -exec test -e "{}"/__init__.py \; -print | sed 's/.\///' | tr '\n' ' ')
        echo "Found packages: $PACKAGES"
        echo "PACKAGES=$PACKAGES" >> $GITHUB_ENV
        # Create coverage include pattern
        COVERAGE_INCLUDE=$(echo "$PACKAGES" | sed 's/ /,/g')
        echo "COVERAGE_INCLUDE=$COVERAGE_INCLUDE" >> $GITHUB_ENV

    - name: Get changed files
      id: changed-files
      run: |
        # Get list of changed Python files
        CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep "\.py$" | grep -v "test_" | tr '\n' ' ')
        if [ -n "$CHANGED_FILES" ]; then
          echo "Changed Python files: $CHANGED_FILES"

          # Extract module paths from changed files (convert file paths to module paths)
          CHANGED_MODULES=$(echo "$CHANGED_FILES" | sed -E 's|/|.|g' | sed -E 's|\.py$||g' | sed -E 's|^\.|.|g' | tr ' ' ',')
          echo "Changed modules: $CHANGED_MODULES"
          echo "CHANGED_MODULES=$CHANGED_MODULES" >> $GITHUB_ENV
          echo "HAS_CHANGED_FILES=true" >> $GITHUB_ENV
        else
          echo "No Python files changed"
          echo "HAS_CHANGED_FILES=false" >> $GITHUB_ENV
        fi

    - name: Run tests with coverage for changed files
      if: env.HAS_CHANGED_FILES == 'true'
      run: |
        # Run coverage specifically on changed modules
        python -m pytest tests/ --cov=${{ env.CHANGED_MODULES }} --cov-report=xml:changed_coverage.xml --cov-report=term --cov-fail-under=80

    - name: Run tests with coverage for all packages
      run: |
        # Run coverage for all packages
        python -m pytest tests/ --cov=${{ env.COVERAGE_INCLUDE }} --cov-report=xml --cov-report=term --cov-fail-under=80

    - name: Generate Coverage Reports
      run: |
        # Create a Python script to generate both reports
        cat > generate_coverage_reports.py << 'EOF'
        import xml.etree.ElementTree as ET
        import os
        import sys

        # Parse overall coverage XML
        tree = ET.parse("coverage.xml")
        root = tree.getroot()

        # Calculate overall coverage
        overall_coverage = float(root.attrib["line-rate"]) * 100

        # Check if we have changed files coverage
        has_changed_files = os.environ.get('HAS_CHANGED_FILES', 'false') == 'true'
        changed_coverage = None

        if has_changed_files and os.path.exists("changed_coverage.xml"):
            # Parse changed code coverage XML
            changed_tree = ET.parse("changed_coverage.xml")
            changed_root = changed_tree.getroot()

            # Calculate coverage for changed code
            changed_coverage = float(changed_root.attrib["line-rate"]) * 100

        # Open report file
        with open("coverage_report.md", "w") as f:
            f.write("## Test Coverage Report\n\n")

            # Add warning and details if changed code coverage is low
            if has_changed_files and changed_coverage is not None:
                if changed_coverage < 80:
                    f.write("⚠️ **Warning: New code coverage is below the 80% threshold!**\n\n")

                f.write(f"### New Code Coverage: {changed_coverage:.2f}%\n\n")
                f.write("| Changed Module | Coverage | Status |\n")
                f.write("| -------------- | -------- | ------ |\n")

                # Add each changed module
                for pkg in changed_tree.findall(".//package"):
                    pkg_name = pkg.attrib["name"]
                    pkg_coverage = float(pkg.attrib["line-rate"]) * 100
                    status = "✅" if pkg_coverage >= 80 else "❌"
                    f.write(f"| {pkg_name} | {pkg_coverage:.2f}% | {status} |\n")

                f.write("\n")

            f.write(f"### Overall Coverage: {overall_coverage:.2f}%\n\n")
            f.write("| Module | Coverage |\n")
            f.write("| ------ | -------- |\n")

            # Add each package
            for pkg in root.findall(".//package"):
                pkg_name = pkg.attrib["name"]
                pkg_coverage = float(pkg.attrib["line-rate"]) * 100
                f.write(f"| {pkg_name} | {pkg_coverage:.2f}% |\n")

            # If there are changed modules with low coverage, add details about missing lines
            if has_changed_files and changed_coverage is not None and changed_coverage < 80:
                f.write("\n### Missing Coverage in Changed Files\n\n")
                for pkg in changed_tree.findall(".//package"):
                    pkg_name = pkg.attrib["name"]
                    pkg_coverage = float(pkg.attrib["line-rate"]) * 100

                    if pkg_coverage < 80:
                        f.write(f"#### {pkg_name}\n\n")
                        for cls in pkg.findall(".//class"):
                            cls_name = cls.attrib["name"]
                            missing_lines = []

                            for line in cls.findall(".//line"):
                                if line.attrib.get("hits") == "0":
                                    missing_lines.append(line.attrib["number"])

                            if missing_lines:
                                f.write(f"- **{cls_name}**: Lines missing coverage: {', '.join(missing_lines)}\n")

        # Write a file with success/failure indication for GitHub Actions
        with open("coverage_check_result.txt", "w") as f:
            if has_changed_files and changed_coverage is not None and changed_coverage < 80:
                f.write("FAIL")
                sys.exit(1)  # Exit with error if changed code doesn't meet threshold
            else:
                f.write("PASS")
        EOF

        # Run the script
        python generate_coverage_reports.py || echo "Coverage check completed with warnings"

    - name: Check coverage results
      id: coverage-check
      run: |
        if [ -f "coverage_check_result.txt" ] && [ "$(cat coverage_check_result.txt)" == "FAIL" ]; then
          echo "::error::New code coverage is below the required threshold!"
          # We don't fail the build here, just add the warning
        fi

    - name: Find Comment
      uses: peter-evans/find-comment@v2
      id: fc
      with:
        issue-number: ${{ github.event.pull_request.number }}
        comment-author: 'github-actions[bot]'
        body-includes: Test Coverage Report

    - name: Create or update PR comment with coverage
      uses: peter-evans/create-or-update-comment@v3
      with:
        comment-id: ${{ steps.fc.outputs.comment-id }}
        issue-number: ${{ github.event.pull_request.number }}
        body-file: coverage_report.md
        edit-mode: replace

    - name: Run linting
      run: |
        python -m ruff check . --output-format=github
      continue-on-error: true  # Don't fail the workflow, just report issues
